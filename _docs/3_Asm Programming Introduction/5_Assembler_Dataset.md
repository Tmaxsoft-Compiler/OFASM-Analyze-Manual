---
title: Assembler 데이터셋
category: ASM Programming Introduction
order: 5
---

## 목차

- [목차](#목차)
- [Assembler Dataset](#assembler-dataset)
  - [Data Control Block Definition (DCB)](#data-control-block-definition-dcb)
  - [DCB kinds of parameters](#dcb-kinds-of-parameters)
  - [Dataset i/o macro](#dataset-io-macro)
  - [Vsam control macro](#vsam-control-macro)
    - [Generate a control block (GENCB) <br>](#generate-a-control-block-gencb-)
    - [GENCB kinds of Parameters](#gencb-kinds-of-parameters)
    - [Generate an access method control block (ACB) <br>](#generate-an-access-method-control-block-acb-)
    - [ACB kinds of Parameters](#acb-kinds-of-parameters)
    - [Create a request parameter list (RPL)](#create-a-request-parameter-list-rpl)
    - [RPL kinds of Parameters](#rpl-kinds-of-parameters)
  
----

## Assembler Dataset
### Data Control Block Definition (DCB)
데이터 제어 블록(DCB)이라고 하는 파일 정의는 어셈블러 프로그래머가 프로그램에서 액세스하려는 각 파일에 대해 생성되어야 한다. DCB는 외부 파일에 대한 정보를 유지 관리하는 특별한 종류의 데이터 영역이다. DCB는 시스템 매크로 명령을 사용하여 생성된다.

DCB에는 다음이 포함됩니다.
* 데이터를 참조하는 데 사용되는 이름
* 데이터세트 내 레코드 및 블록의 형식 및 크기
* 데이터셋에 접근하기 위한 명령어의 종류와 데이터셋의 현재 상태

대부분의 어셈블러 프로그램의 주요 목적은 데이터(INPUT)를 읽고 처리한 다음 결과 데이터(OUTPUT)를 인쇄하는 것이다. 프로그램에서 입력 및 출력 데이터를 처리하는 주요 단계는 아래와 같다. I/O 매크로는 어셈블러 명령어로 수행되는 I/O 영역의 정의를 제외하고 이러한 모든 작업을 수행하는 데 사용된다. 아래 관려 그림이다.

![dataset_input_output_macro]({{site.baseurl}}/attach/dataset_input_output_macro.png)

I/O를 처리하는 모든 어셈블러 프로그램은 처리할 데이터 세트에 대한 정보를 어셈블러에 제공해야 한다. 데이터는 순차적으로 구성되고 동일한 방식으로 DCB(Data Control Block) 매크로에 의해 처리된다. DCB 매크로 명령어는 데이터 세트를 처리하기 위해 큰 블록의 상수를 생성한다. 상수 블록은 처리 중인 데이터 세트의 모양을 제어하는 데이터 필드(또는 매개변수) 세트이다.

DCB는 다음을 포함하여 데이터 세트에 관한 정보를 포함하는 데이터 필드 모음이다. 아래 관려 항목과 그림이다.
* 기록의 크기와 형식
* 데이터 처리에 사용되는 I/O 매크로
* 데이터 세트의 이름 및 현재 상태

![dcb_data_field]({{site.baseurl}}/attach/dcb_data_field.png)

### DCB kinds of parameters
다양한 키워드 매개변수가 입력 및 출력 DCB와 함께 사용된다. DDNAME 매개변수는 이 DCB가 나타내는 외부 파일에 대한 링크로 사용된다. DDNAME 매개변수의 값은 일괄 실행을 위한 JCL DD 문의 DDNAME 또는 대화식 실행을 위한 ALLOCATE TSO 문의 FILE 매개변수와 일치해야 한다. 아래 관련 그림이다.

![dcb_ddname_using]({{site.baseurl}}/attach/dcb_ddname_using.png)

DCB macro 의 매개변수로 아래와 같은 종류가 올수 있다 :
* DSORG 매개변수는 이 DCB가 나타내는 데이터 세트의 구성을 지정한다. 이 과정의 예에서 매개변수는 Physical Sequential의 약어인 PS를 사용하고 있다. 
* MACRF 매개변수는 데이터 세트의 레코드에 액세스하는 데 사용되는 매크로 형식을 지정한다. 입력에 대해 GM(GET 매크로 모드)을 지정하고 출력에 대해 PM(PUT 매크로 모드)을 지정한다.
* RECFM 매개변수는 처리 중인 데이터 세트의 레코드 형식을 지정한다. 입력에 대해 FB(고정 길이 레코드)를 지정하고 출력에 FBA(미국 국립 표준 연구소(ANSI) 프린터 제어 문자가 있는 고정 길이 레코드)를 지정한다.
* LRECL 매개변수는 데이터 세트의 레코드 길이를 지정한다. 예에서는 입력에 대해 80을 지정하고 출력에 대해 133을 지정한다.
* BLKSIZE 매개변수는 데이터 세트에서 물리적 레코드 또는 블록의 크기를 지정한다. 예에서는 입력 데이터 세트에 대해 이 매개변수를 생략하고 출력에 6650을 사용하고 있다.
* EODAD 매개변수(데이터 주소 끝)는 GET이 시도되고 더 이상 데이터가 없을 때 제어가 전송될 프로그램의 레이블을 지정한다. 이 매개변수는 입력 데이터 세트에만 지정된다.

![dcb_parameter]({{site.baseurl}}/attach/dcb_parameter.png)

### Dataset i/o macro
* OPEN macro <br>
  데이터 세트에 대한 입력 및 출력 작업을 수행하려면 먼저 데이터 세트를 열거나 처리할 수 있어야 한다. 이를 위해 OPEN 매크로 명령어를 사용한다. OPEN 매크로는 운영 체제 루틴을 호출하여 데이터 세트가 있는지 확인하고 사양과 일치하는지 확인하고 처리를 위해 준비하는 실행 가능한 명령을 생성한다. 출력 데이터 세트의 경우 JCL 또는 ALLOCATE 문에서 지정하면 OPEN은 새 데이터 세트를 생성한다. 아래 관련 그림이다.
  
  ![open_macro]({{site.baseurl}}/attach/open_macro.png)

* CLOSE macro <br>
  DCB가 open 되면 코드 데이터 전송 매크로, 입력용 GET 및 출력용 PUT. 이러한 매크로에 의해 I/O 처리가 끝나면 프로그램을 종료하기 전에 DCB를 닫는다. CLOSE 매크로는 파일 하우스키핑에 사용한다. 아래 관련 그림이다.
  
  ![close_macro]({{site.baseurl}}/attach/close_macro.png)

* GET macro <br>
  데이터 세트가 open 되면 GET 매크로는 데이터 세트의 다음 논리 레코드를 작업 영역으로 읽는다. 입력 모드에서 GET 매크로의 형식은 아래와 같다. 지금까지 사용된 이름을 사용하여 매크로는 아래와 같이 코딩된다. 입력 데이터의 끝에 도달하고 다른 GET 매크로가 실행되면 제어는 DCB 매크로에서 EODAD로 지정된 주소로 전송된다. 아래 관련 그림이다.
  
  ![get_macro]({{site.baseurl}}/attach/get_macro.png)

* PUT macro <br>
  PUT 매크로는 작업 영역에서 출력 데이터 세트로 다음 논리 레코드를 쓰는 데 사용된다. 출력 모드에서 PUT 매크로의 형식은 아래와 같이 표시된다. 이때까지 사용한 이름을 사용하면 아래와 같이 코딩된다. 아래 관련 그림이다.

  ![put_macro]({{site.baseurl}}/attach/put_macro.png)


### Vsam control macro
VSAM을 사용하여 데이터를 구성하고 카탈로그에서 해당 데이터에 대한 정보를 유지 관리 및  액세스 방법 서비스 명령 및 VSAM 매크로를 사용하여 VSAM 프로그래밍을 수행한다.

#### Generate a control block (GENCB) <br>
GENCB 매크로 명령어는 ACB, EXLST, RPL 종류의 블록을 생성할 수 있다. GENCB 매크로 명령어 사용의 장점은 프로그램 실행 중에 제어 블록이 생성된다는 것이다. GENCB는 프로그램 실행 중에 제어 블록을 구축할 뿐만 아니라 동적으로 할당된 저장소에 제어 블록을 구축할 수도 있다. 해당 MACRO 운용의 한 가지 장점은 각 제어 블록의 길이에 대한 응용 프로그램 종속성을 제거할 수 있다는 것이다.

응용 프로그램의 저장소에 제어 블록을 구축하려면 응용 프로그램이 프로그램 조립 중에 제어 블록을 수용할 만큼 충분한 저장소를 예약하거나 필요한 저장소를 확보하기 위해 운영 체제 저장소 조작 매크로 명령(GETMAIN)을 실행해야한다. 운영 체제 매크로 명령이 사용되는 경우 이 저장소의 위치와 길이는 GENCB 매크로 명령에 코딩되어야 한다. 위치 및 길이 피연산자(WAREA 및 LENGTH)가 생략되면 제어 블록에 대한 동적 스토리지 할당이 자동으로 발생한다. 아래 관련 그림이다.

![gencb_macro]({{site.baseurl}}/attach/gencb_macro.png)

#### GENCB kinds of Parameters
1. AM=VTAM : 이 매크로 명령을 VTAM 매크로 명령으로 식별한다. 이 피연산자는 필수이다.
2. BLK : 생성할 제어 블록의 유형을 나타낸다.
  - BLK=ACB : ACB 제어 블록이 생성된다.
  - BLK=EXLST : EXLST 제어 블록이 생성된다.
  - BLK=RPL : RPL 제어 블록이 생성된다.
3. LENGTH= work_area_length : WAREA 피연산자가 지정한 저장 영역의 길이(바이트)를 나타낸다.
4. MF=E, G 또는 L : GENCB의 실행, 생성 또는 나열 형식이 사용됨을 나타낸다. 이 피연산자를 생략하면 GENCB의 표준 형식이 사용된다.
5. WAREA= work_area_address : 제어 블록이 구축될 응용 프로그램의 저장 영역 위치를 나타낸다. 이 피연산자가 지정되면 LENGTH 피연산자도 지정해야 한다.

#### Generate an access method control block (ACB) <br>
ACB 매크로 하위 매개변수의 값은 절대 숫자 표현식, 문자열, 코드 및 재배치 가능한 유효한 A 타입 주소 상수를 생성하는 표현식으로 지정할 수 있다.

VTAM을 사용하는 각 응용 프로그램은 ACB를 정의하고 열어야 합니다. 응용 프로그램은 둘 이상의 ACB를 포함할 수 있지만, 각 ACB는 다른 응용 프로그램 이름을 나타내야 한다.

ACB가 열린 후에는 세션 설정 요청, 통신 작업 요청, 네트워크 관리 요청과 같은 VTAM 서비스에 대한 요청이 수행될 수 있다. ACB가 닫히면(CLOSE 매크로 명령 사용) 이러한 요청은 더 이상 수행될 수 없으며 설정된 세션이 종료된다.

ACB를 사용하여 응용 프로그램은 종료 루틴 주소 목록의 주소를 제공할 수 있다. 이 목록에 표시된 루틴은 오류 조건 또는 세션 설정 요청과 같은 특수 이벤트가 발생할 때 VTAM에 의해 호출된다.

ACB는 GENCB 매크로 명령을 사용하여 프로그램 실행 중에도 빌드할 수 있다. ACB는 MODCB 매크로 명령을 사용하여 프로그램을 실행하는 동안 또는 IFGACB 매핑 매크로 명령에 의해 생성된 DSECT를 사용하여 수정되지만 ACB가 열리기 전에만 수정된다.

OPEN 및 CLOSE 매크로 명령이 참조하는 ACB 제어 블록은 31비트 또는 24비트 저장소에 있을 수 있지만 응용 프로그램의 주소 지정 모드와 일치해야 한다. MODE 매개변수는 이러한 매크로 명령에 대한 ACB 제어 블록의 주소 지정 모드를 설정하는 데 사용된다.

#### ACB kinds of Parameters
1. DDNAME=문자열 : <br>
   데이터 세트에 대한 JCL DD 문을 지정하여 처리하려는 데이터 세트를 식별하는 1 - 8자를 지정한다. DDNAME을 생략하고 데이터 세트를 열기 전에 레이블이나 MODCB 매크로를 통해 제공할 수 있다.
2. EXLST=주소 : <br>
   제공하는 종료 루틴 주소 목록의 주소를 지정한다. 목록은 EXLST 또는 GENCB 매크로로 설정해야 한다. 이 매개변수를 생략하면 종료 루틴이 없음을 의미합니다.
3. STRNO=abs expression : <br>
   VSAM이 처리할 준비가 된 동시 데이터 세트 위치 지정이 필요한 요청 수를 지정한다. STRNO는 1에서 255 사이의 숫자여야 한다. 기본값은 1이다. 요청은 지정된 요청 매개변수 목록 또는 요청 매개변수 목록 체인에 의해 정의된다. 문자열 번호는 리소스 풀을 공유하는 모든 데이터 세트에 대해 동시에 발행된 요청 수와 같다.
4. MACRF=([ADR][,CNV][,<U>KEY</U>] <br>
  [,CFX|<U>NFX</U>] <br>
  [,<U>DDN</U>|DSN] <br>
  [,DFR|<U>NDF</U>] <br>
  [,DIR][,<U>SEQ</U>][,SKP] <br>
  [,ICI|<U>NCI</U>] <br>
  [,<U>IN</U>][,OUT] <br>
  [,<U>LEW</U>|NLW] <br>
  [,<U>NIS</U>|SIS] <br>
  [,<U>NRM</U>|AIX] <br>
  [,<U>NRS</U>|RST] <br>
  [,<U>NSR</U>|LSR|GSR|RLS] <br>
  [,<U>NUB</U>|UBF]) : <br>
  데이터 세트로 수행할 처리 유형을 지정한다. 하위 매개변수는 데이터 세트에 따라 결정된다. 예를 들어, ESDS(entry-sequenced data set)에 대해 키 액세스를 지정하면 데이터 세트를 열 수 없다. 동시에 사용하거나 하나에서 다른 것으로 전환하여 사용할 모든 액세스 유형을 지정해야 합니다. 각 하위 매개변수 그룹에는 기본값이 있다(밑줄로 표시됨). 임의의 순서로 하위 매개변수를 지정할 수 있다. ADR과 KEY를 모두 지정하여 KSDS(키 시퀀스 데이터 세트)를 처리할 수 있다. DIR과 SEQ를 모두 지정할 수 있다. 키 액세스를 사용하면 SKP도 지정할 수 있다. OUT을 지정하고 일부 레코드만 검색하고 다른 레코드를 업데이트, 삭제 또는 삽입하려는 경우 IN도 지정할 필요가 없다.

  |옵션|의미|
  |----|----|
  |ADR|키 시퀀싱 또는 엔트리 시퀀싱 데이터 세트에 대한 액세스 주소 지정 RBA는 검색 인수로 사용되며 순차 액세스는 입력 순서에 따라 이루어진다. VSAM RLS는 KSDS에 대한 ADR 액세스를 지원하지 않는다.|
  |CNV|액세스는 개별 데이터 레코드가 아니라 제어 간격의 전체 내용에 대한 것이다. 데이터 세트가 암호로 보호된 경우 ACB PASSWD 매개변수에 제어 또는 상위 수준 암호의 주소를 제공해야 한다.|
  |KEY|RRDS(상대 레코드 데이터 세트) 또는 키 시퀀스 데이터 세트에 대한 키 액세스. 키 또는 상대 레코드 번호가 검색 인수로 사용되며 순차 액세스는 키 또는 상대 레코드 번호에 의해 수행된다. KEY 처리는 RLS의 영향을 받지 않는다.|
  |CFX|ICI를 사용하는 경우 OPEN은 제어 블록과 I/O 버퍼를 수정하고 ACB가 닫힐 때까지 고정된 상태로 유지된다.|
  |NFX|OPEN은 제어 블록이나 I/O 버퍼를 수정하지 않는다. VSAM은 필요에 따라 동적으로 페이지를 수정 및 수정 해제한다.|
  |DDN|하위 작업 공유 제어 블록 연결은 공통 ddnames를 기반으로 한다.|
  |DSN|하위 작업 공유 제어 블록 연결은 공통 데이터 세트 이름을 기반으로 한다.|
  |DFR|공유 리소스를 사용하면 직접 PUT 요청에 대한 쓰기가 WRTBFR 매크로가 실행될 때까지 또는 VSAM이 GET 요청을 충족하기 위해 버퍼가 필요할 때까지 연기한다. 쓰기 연기는 버퍼 풀에 이미 있는 데이터로 후속 요청을 충족할 수 있는 경우에 I/O 요청을 저장한다. RLS의 경우 DFR은 무시되고 직접 요청 수정 버퍼는 디스크와 CF(커플링 기능)에 즉시 기록됩니다.|
  |NDF|직접 PUT의 경우 쓰기가 지연되지 않는다. RLS의 경우 NDF는 무시되고 직접 요청 수정 버퍼는 디스크와 CF(커플링 기능)에 즉시 기록된다.|
  |DIR|RRDS, KSDS 또는 ESDS에 대한 직접 액세스한다.|
  |SEQ|RRDS, KSDS 또는 ESDS에 대한 순차적 액세스한다.|
  |SKP|RRDS 또는 KSDS에 대한 순차 액세스 건너뛰기. 정방향에서 키 액세스에만 사용된다.|
  |ICI|처리는 개선된 제어 간격 처리로 제한된다. 더 적은 수의 프로세서 명령어가 실행되기 때문에 액세스가 더 빠르다. 확장 형식 데이터 세트에는 ICI 처리가 허용되지 않는다.|
  |NCI|개선된 control interval 처리 이외의 처리한다.|
  |IN|RRDS, KSDS 또는 ESDS의 기록을 검색을 허용한다.(빈 데이터 세트에는 허용되지 않는다).|
  |OUT|RRDS, KSDS 또는 ESDS에 새 기록 저장가능하다.(KSDS에 대한 주소 지정 액세스에는 허용되지 않음). RRDS, KSDS 또는 ESDS의 기록 업데이트. RRDS 또는 KSDS에서 기록 삭제가능하다.|
  |LEW|LSR을 사용하여 배타적 제어 충돌이 발생하면 VSAM은 리소스를 사용할 수 있게 될 때까지 요청을 연기한다.|
  |NLW|이 값이 지정되면 VSAM은 요청을 연기하는 대신 독점 제어 리턴 코드 20( X'14' )을 애플리케이션 프로그램에 리턴한다 . 그러면 응용 프로그램이 다음 조치를 결정할 수 있게 된다.|
  |NIS|일반적인 삽입 전략이다.|
  |SIS|순차 삽입 전략이다.(직접 PUT을 수행할 때 중간 지점이 아닌 삽입 지점에서 제어 간격 및 제어 영역을 분할한다.) 각 직접 PUT 요청 후에 위치 지정이 손실되고 쓰기가 수행되지만 직접 삽입이 특정 키 주위에 클러스터링될 때 SIS는 보다 효율적인 공간 사용을 허용한다.|
  |NRM|처리할 개체는 지정된 ddname에 명명된 개체이다.|
  |AIX|처리할 개체는 대체 인덱스를 통한 기본 클러스터가 아니라 ddname으로 지정된 경로의 대체 인덱스이다. RLS의 경우 AIX 하위 매개변수가 유효하지 않는다.|
  |NRS|데이터 세트는 재사용할 수 없게 된다.|
  |RST|데이터 세트를 재사용할 수 있게 된다.(사용 빈도가 높은 RBA는 OPEN 동안 0으로 재설정됨).|
  |NSR|비공유 리소스를 의미한다.|
  |LSR|로컬 공유 리소스를 의미한다. 각 주소 공간은 다른 주소 공간과 독립적으로 최대 256개의 인덱스 리소스 풀과 256개의 데이터 리소스 풀을 가질 수 있다. 기본값인 SHRPOOL=0을 사용하지 않는 경우 사용 중인 자원 풀을 나타내기 위해 SHRPOOL 매개변수를 지정해야 한다. LSR을 지정하면 데이터 세트가 BLDVRP 매크로에 의해 구축된 로컬 리소스 풀을 사용하게 된다. OPEN 매크로가 발행되는 시점에 인덱스 리소스 풀이 존재하면 KSDS용 인덱스가 인덱스 리소스 풀에 연결된다.|
  |GSR|글로벌 공유 자원을 의미한다. 모든 주소 공간에는 로컬 및 글로벌 리소스 풀이 있을 수 있으며, 여기서 로컬 리소스 풀이 있는 주소 공간의 작업은 로컬 리소스 풀 또는 글로벌 리소스 풀을 사용할 수 있다. 이 매개변수는 압축 형식 데이터 세트에 유효하지 않는다.|
  |RLS|RLS는 VSAM 레코드 수준 공유 프로토콜이 사용되도록 지정한다. RLS 및 NSR/LSR/GSR은 상호 배타적이다. RLS는 VSAM이 CI 잠금과 반대되는 교차 시스템 레코드 수준 잠금을 사용하고 버퍼 일관성을 위해 CF를 사용하며 시스템 전체의 로컬 캐시를 관리함을 의미한다.|
  |NUB|I/O 버퍼의 관리는 VSAM이 맡는다. RLS의 경우 NUB를 지정해야 한다.|
  |UBF|I/O 버퍼의 관리는 사용자에게 있다. RPL(또는 GENCB) AREA 매개변수에 의해 지정된 작업 영역은 I/O 버퍼이다. VSAM은 작업 영역과 직접 액세스 저장소 간에 제어 간격의 내용을 직접 전송한다. UBF 는 OPTCD=MVE 및 MACRF=CNV가 지정된 경우에 유효하다. ICI가 지정되면 UBF가 가정된다. RLS의 경우 UBF는 유효하지 않는다.|
  
#### Create a request parameter list (RPL) 
응용 프로그램이 세션 설정 또는 통신을 위해 만드는 모든 요청은 요청 매개변수 목록(RPL)을 참조해야 한다.

응용 프로그램은 RPL을 사용하여 VTAM에 대한 대부분의 요청을 설명한다. 예를 들어 응용 프로그램은 RECEIVE를 발행하고 RPL을 표시할 수 있다. RPL은 VTAM에서 입력을 얻을 세션, 입력 데이터를 배치할 위치, 작업이 완료된 후 응용 프로그램에 알리는 방법 및 요청 처리 중에 따라야 하는 기타 옵션을 보여준다.

RPL 매크로 명령어는 어셈블리 중에 RPL을 빌드한다. 또한 GENCB 매크로 명령어는 프로그램 실행 중에 RPL을 생성할 수 있다. RPL 수정 요청은 RPL 기반 요청의 일부로 또는 MODCB 매크로 명령에 의해 수행될 수 있다. 어느 쪽이든 RPL 필드의 이름을 지정하고 새 값을 지정해야 한다. 또한 IFGRPL DSECT는 RPL 필드 값을 변경할 수 있다.

모든 RPL 피연산자는 선택적이며(AM=VTAM 제외) RPL 기반 매크로 명령어 중 하나로 지정할 수 있지만 각 RPL 기반 매크로 명령어는 매크로 명령어가 실행될 때 특정 RPL 필드를 설정해야 한다.

#### RPL kinds of Parameters
1. ACB=acb_address : <br>
   이 RPL을 사용하는 요청을 ACB와 연결한다. 이 피연산자를 생략하면 ACB 필드가 0으로 설정된다.
2. AREA=data_area_address : <br>
   사용자가 요청하는 경우 VSAM이 데이터 레코드를 이동하는 작업 영역의 주소를 지정한다(RPL 매개변수 OPTCD=MVE 사용). 요청이 I/O 버퍼(OPTCD=LOC)의 레코드를 처리하는 것이라면 VSAM은 I/O 버퍼 내의 데이터 레코드 주소를 이 작업 영역에 넣는다.
3. AREALEN=data_area_length : <br>
   주소가 AREA 매개변수에 의해 지정된 작업 영역의 길이(바이트)를 지정한다. OPTCD=MVE에 대한 최소값은 데이터 레코드(가변 길이의 레코드가 있는 데이터 세트의 경우 가장 큰 데이터 레코드)의 크기이다. OPTCD=LOC의 경우 I/O 버퍼 내의 데이터 레코드 주소를 포함하려면 영역이 4바이트여야 한다.
4. ARG=address : <br> 
   직접 검색,  skip-sequential 검색 및 위치 지정을 위한 검색 인수가 포함된 필드의 주소를 지정한다. RRDS의 경우 ARG 필드의 길이는 4바이트여야 한다. 직접 또는 skip-sequential 처리의 경우 이 필드에는 검색 인수인 상대 레코드 번호가 포함된다. 순차 처리(OPTCD=(KEY,SEQ))의 경우 VSAM이 피드백 RRN을 반환하는 데 4바이트가 필요하다. 키 액세스(OPTCD=KEY)의 경우 검색 인수는 전체 또는 일반 키 또는 상대 레코드 번호이다. 주소 지정 액세스(OPTCD=ADR)의 경우 검색 인수는 RBA이다. 일반 키(OPTCD=GEN)를 지정하는 경우 일반 키에 사용 중인 전체 키의 바이트 수를 KEYLEN 매개변수에 지정해야 한다.
5. ECB=address : <br> 
   제공할 수 있는 이벤트 제어 블록(ECB)의 주소를 지정한다. VSAM은 요청이 완료되었는지 여부를 ECB에서 표시한다. ECB를 사용하여 CHECK 매크로를 실행하기 전에 비동기 요청이 완료되었는지 확인할 수 있다. ECB 매개변수는 항상 선택 사항이다.
6. MSGAREA=address : <br> 
   물리적 오류가 발생한 경우 VSAM이 메시지를 보내도록 선택적으로 제공할 수 있는 영역의 주소를 지정한다.
7. MSGLEN= abs 표현식 : <br> 
   MSGAREA 매개변수에 표시된 메시지 영역의 크기(바이트)를 지정한다. MSGAREA가 지정되면 MSGLEN이 필요하다. 메시지의 최소 크기는 128바이트이다. 128바이트 미만을 제공하면 프로그램에 메시지가 반환되지 않는다.
8. NXTRPL=address : <br>
   체인에서 다음 요청 매개변수 목록의 주소를 지정합니다. 체인의 마지막 목록을 생성하는 매크로에서 이 매개변수를 생략하십시오. 요청 매개변수 목록 체인에 의해 정의된 요청을 발행할 때 요청 매크로에 체인의 첫 번째 매개변수 목록 주소를 표시하십시오. 이 매개변수는 UNIX 파일에 대해 지원되지 않으며 0이 아닌 값으로 지정된 경우 후속 GET, PUT 또는 POINT 요청에서 오류가 발생합니다.
9. TIMEOUT= 숫자 : <br>
   RLS 및 DFSMStvs의 경우 다른 프로그램이 이미 레코드에 대한 잠금을 보유하고 있을 때 프로그램이 VSAM 레코드에 대한 잠금을 획득하기 위해 대기할 시간(초)을 지정한다. TIMEOUT의 0이 아닌 값은 이 프로그램이 다른 프로그램이 잠금을 해제할 때까지 대기하는 시간(초)을 지정한다. 0 값은 이 요청에 대해 VSAM이 TIMEOUT 처리를 수행하지 않도록 지정한다. 즉, 요청에 필요한 레코드 잠금이 다른 프로그램에 의해 유지되는 경우 프로그램은 잠금을 해제할 수 있는 시간에 관계없이 다른 프로그램이 잠금을 해제할 때까지 기다린다. 이 매개변수에 지정하는 모든 값은 JCL에서 RLSTMOUT을 사용하여 지정된 값을 대체한다.
10. OPTCD=([ADR|CNV|<U>KEY</U>] <br>
    [,DIR|<U>SEQ</U>|SKP] <br>
    [,<U>ARD</U>|LRD] <br>
    [,<U>FWD</U>|BWD] <br>
    [,ASY|<U>SYN</U>] <br>
    [,NSP|<U>NUP</U>|UPD] <br>
    [,<U>KEQ</U>|KGE] <br>
    [,<U>FKS</U>|GEN] <br>
    [,<U>NWAITX</U>|WAITX] <br>
    [,LOC|<U>MVE</U>] <br>
    [,CR|CRE|NRI] <br>
    [,<U>RBA</U>|XRBA]) : <br>
   요청 매개변수 목록에 의해 정의된 요청을 관리하는 하위 매개변수를 지정한다. 각 하위 매개변수 그룹에는 기본값이 있다.(밑줄 친 매개변수이다.). 각 그룹에서 하나의 하위 매개변수만 지정할 수 있다. 일부 요청에는 모든 그룹의 하위 매개변수를 지정할 필요가 없다.

   |옵션|의미|
   |----|----|
   |ADR|키 시퀀스 또는 항목 시퀀스 데이터 세트에 대한 주소 지정 액세스: RBA는 검색 인수로 사용되며 순차적 액세스는 항목 시퀀스에 의해 수행된다. VSAM RLS 및 DFSMStv는 KSDS에 대한 주소 지정 액세스를 지원하지 않는다.|
   |CNV|제어 간격 액세스이다. 압축된 데이터 세트에는 제어 간격 액세스가 허용되지 않는다. VSAM RLS 및 DFSMStv는 CNV 액세스를 지원하지 않는다.|
   |KEY|RRDS 또는 KSDS에 대한 키 액세스이다. 키 또는 상대 레코드 번호는 검색 인수로 사용되며 순차 액세스는 키 또는 상대 레코드 번호 시퀀스에 의해 수행된다.|
   |DIR|RRDS, KSDS 또는 ESDS에 대한 직접 액세스이다.|
   |SEQ|RRDS, KSDS 또는 ESDS에 대한 순차적 액세스이다.|
   |SKP|순차 액세스를 Skip 한다.|
   |ARD|사용자의 인수는 찾거나 검색하거나 저장할 레코드를 결정한다.|
   |LRD|데이터 세트의 마지막 레코드는 찾거나(POINT) 검색(GET direct)된다. OPTCD=BWD가 필요하다.|
   |FWD|정방향으로 진행하는 처리이다.|
   |BWD|역방향으로 진행하는 처리이다. 키(KEY) 또는 주소 지정(ADR) 순차(SEQ) 또는 직접(DIR) 요청의 경우 POINT, GET, PUT 및 ERASE 작업에 유효하다. OPTCD=BWD를 사용하는 POINT 또는 OPTCD=(NSP,BWD)를 사용하여 직접 GET에 의해 위치 지정을 설정한다. OPTCD=BWD가 지정되면 하위 매개변수 KGE 및 GEN은 무시되고 하위 매개변수 KEQ 및 FKS가 가정된다.|
   |ASY|비동기 액세스를 의미한다. VSAM은 요청이 수행되는 동안 프로그램이 다른 처리를 수행할 수 있도록 요청을 예약한 후 처리 프로그램으로 돌아간다.|
   |SYN|동기 액세스를 의미한다. VSAM은 요청을 완료한 후 처리 프로그램으로 돌아간다.|
   |NSP|OPTCD=DIR에서만 유효하다. VSAM은 위치를 기억한다.(이후 순차 액세스를 위해). 즉, ENDREQ 매크로가 발행되지 않는 한 위치를 잊어선 안된다.|
   |NUP|검색 중인 데이터 레코드는 업데이트되거나 삭제되지 않는다. 저장 중인 레코드는 항상 새 레코드이다. VSAM은 작업 영역에 대한 직접 요청에 대한 위치를 기억하지 않는다.|
   |UPD|검색 중인 데이터 레코드를 업데이트하거나 삭제할 수 있다. 저장 또는 삭제 중인 레코드가 이전에 OPTCD=UPD로 검색되었다면, VSAM은 순차 및 직접 GET 요청에 대한 위치를 기억한다. DIR UPD GET 요청 후에 PUT, ERASE 또는 ENDREQ가 발행되면 VSAM이 배타적 제어를 해제한다.|
   |KEQ|OPTCD=(KEY,DIR) 또는 (KEY,SKP)가 있는 GET 및 OPTCD=KEY가 있는 POINT의 경우 검색 인수에 제공하는 키(전체 또는 일반)는 레코드의 키 또는 상대 레코드 번호와 같아야 한다. RRDS의 경우 POINT를 제외하고 KEQ가 가정된다.|
   |KGE|KEQ와 동일한 경우에 검색 인수에 제공한 키(전체 또는 일반)가 레코드의 키와 같지 않으면 요청은 다음으로 높은 키가 있는 레코드에 적용된다. RRDS와 함께 POINT를 사용하는 경우 KGE는 슬롯이 비어 있는지 여부에 관계없이 지정된 상대 레코드 번호로 위치를 지정한다. 상대 레코드 번호가 가장 높은 기존 레코드보다 크면 EOD가 반환된다. 후속 PUT은 이 위치에 레코드를 삽입한다.|
   |FKS|전체 키가 검색 인수로 제공된다.|
   |GEN|일반 키는 검색 인수로 제공된다. KEYLEN 매개변수에 길이를 지정해야한다. 가변 길이 RRDS에는 일반 키가 지원되지 않는다.|
   |NWAITX|UPAD 또는 RLSWAIT로 EXIT 되어선 안된다.|
   |WAITX|OPTCD=SYN 및 ACB의 MACRF=LSR GSR 및 UPAD가 EXIT 로 지정되면 VSAM이 일반적으로 WAIT를 발행하는 지점에서 VSAM이 UPAD EXIT로 수행된다.|
   |LOC|검색을 위해 VSAM은 데이터 세트가 압축되지 않는 한 처리를 위해 I/O 버퍼에 데이터 레코드를 남겨둔다. 이 경우 VSAM은 레코드를 작업 영역으로 이동한다. PUT 또는 ERASE에는 유효하지 않는다. OPTCD=UPD인 GET에 유효하다. 그러나 레코드를 업데이트하려면 PUT을 발행하기 전에 작업 영역에 새 버전의 레코드를 빌드하고 요청 매개변수 목록 OPTCD를 LOC에서 MVE로 수정해야 한다. 키순 검색의 경우 I/O 버퍼의 키 필드를 수정하면 I/O 레코드를 다시 읽을 때까지 후속 GET 요청에 대해 잘못된 결과가 발생할 수 있다.|
   |MVE|검색을 위해 VSAM은 처리를 위해 데이터 레코드를 작업 영역으로 이동하고 저장을 위해 VSAM은 데이터 레코드를 작업 영역에서 I/O 버퍼로 이동한다.|
   |RBA|주소 지정 액세스(OPTCD=ADR)의 경우 ARG 필드에는 4바이트 RBA의 주소가 포함된다. RBA가 기본값이다. 이 요청에는 확장 주소 지정이 사용되지 않는다.|