---
title: 어셈블러 자산 수정 방법
category: Chapter 01
order: 6
---

## 자산 수정이 필요한 경우

### Packed/Zoned Decimal 부호 변경

<pre>
    UNPK    DATA2,DATA1
    OI      DATA2,X'F0'
</pre>

Packed/Zoned decimal을 사용하는 과정에서 부호 비트를 변경하는 위와 같은 코드는 매우 흔하게 볼 수 있다. PACKED 및 ZONDED 심볼이 아래와 같이 정의되어있다고 가정해보자.

<pre>
DATA1   DC    P'-13745'
DATA2   DS    XL5
</pre>

DATA1을 Zonded decimal로 변경하기 위하여 UNPK 명령어를 사용하는데, 이 명령어를 사용한 뒤에 DATA2는 아래와 같은 값을 가지게 된다.

|   DATA2(Zoned)    |
|   ---             |
|   F1F3F7F4D5      |

Zoned decimal의 부호비트는 마지막 바이트에 포함되어있으므로, 위의 예에서는 **0xD5**에 해당한다. 해당 바이트에서 앞의 4비트가 부호비트이므로, 해당 비트를 Unsigned로 변환하면서 뒤의 4비트는 남겨놓기 위하여 0xF0을 OR 연산을 수행하는 것이다.

OR 연산 수행 후에 DATA2는 아래와 같이 변경된다.

|   DATA2(Zoned)    |
|   ---             |
|   F1F3F7F4**F5**      |

하지만 오픈 환경에서는 zonded decimal의 부호 표기 정책이 메인프레임과 다르기 때문에 이에 따른 코드의 수정이 필요하다.

아래는 메인프레임과 오픈환경의 zoned decimal 부호 표기 방법을 비교한 것이다

|            환경           | Unsigned | Signed Positive | Signed Negative |
|            ---            |    ---   |       ---       |       ---       |
|IBM COBOL                  |     F    |        C        |        D        |
|오픈환경 MFCOBOL/OFCOBOL   |     3    |        3        |        7        |
|오픈환경 NETCOBOL          |     3    |        4        |        5        |

위와 같은 환경 차이로 인해 첫 번째 코드는 각 환경에 따라 아래와 같이 수정 되어야 한다.

#### MFCOBOL 또는 OFCOBOL 대응

<pre>
    UNPK    ZONED,PACKED
    NI      ZONED,X'3F'
</pre>

HEX값 'F0'을 OR 연산하는 것에서 '3F'를 AND 연산하는 것으로 바뀌었다.

#### NETCOBOL 대응
* NETCOBOL 사용 시에는 [OFASM_CONFIG] 설정 방법 참고

<pre>
    UNPK    ZONED,PACKED
    NI      ZONED,X'0F'
    OI      ZONED,X'30'
</pre>

NETCOBOL 대응일 때는 코드가 한 줄 늘어나게 되는데, UNPK 이후 첫 번째 코드에서는 OR 연산이 단순히 AND 연산으로 변경됨으로써 UNPK 결과값의 부호비트를 아예 삭제해버린다.
그 뒤 OR 연산을 통해 Unsigned 표시 비트를 삽입함으로써 동일한 동작을 수행할 수 있도록 한다.

### TRT 테이블 변경

TRT는 문자열을 검사해서 해당 문자열이 올바른 입력값을 가지고 있는지 검사하는 용도로 많이 사용된다. 문자열을 검사하기 위해 사전에 정의된 테이블을 이용하는데, 해당 테이블은 EBCDIC 문자 기반으로 작성된 테이블인 경우가 많기 때문에 이것을 ASCII 기반으로 바꾸는 작업이 필요할 수 있다.

#### TRT 명령어

<pre>
    TRT     D1(L,B1),D2(B2)
</pre>

TRT 명령어는 일반적으로 첫번째 피연산자에는 캐릭터 필드(문자열)를, 두번째 피연산자에는 테이블을 받는 형태로 사용하고 있다. TRT의 동작은 아래와 같다.

<pre>
1. i = 0
2. 첫번째 피연산자가 가리키는 문자열에서 i번째 문자를 선택한다. 이 문자를 C_i라고 명명하자.
3. 두번째 피연산자가 가리키는 테이블에서 C_i의 Hex값만큼 떨어진 곳의 값을 참조한다. 참조한 값을 R_i라고 명명하자.
4. R_i값이 0x00이고 C_i가 문자열의 끝이 아니라면, i를 1 증가시키고 2번째 과정부터 반복한다.
   R_i값이 0x00이고 C_i가 문자열의 끝이라면 CC값을 0으로 세팅하고 종료한다.
   R_i값이 0x00이 아니고, C_i가 문자열의 끝이 아니라면 CC값을 1로 세팅하고 종료한다.
   R_i값이 0x00이 아니고, C_i가 문자열의 끝이라면 CC값을 2로 세팅하고 종료한다.
</pre>

여기서 주목해야할 것은 TRT는 문자를 검사할 때 해당 문자의 Hex값을 대상 테이블의 오프셋으로 이용한다는 점이다. 따라서 대부분의 고객 자산들이 EBCDIC 문자를 기준으로 테이블이 작성되어 있으므로 이것을 ASCII 기반의 테이블로 변경해주어야한다.

#### TRT 테이블 분석 및 변환 방법

##### 어떤 문자를 검사하기 위해 사용되는지 파악한다

예를 들어 아래와 같은 테이블이 있다고 가정하자.

<pre>
TAB1    CL240' '
        XL10'00'
        CL6' '
</pre>

TRT 연산자는 테이블의 오프셋에 해당하는 Hex 값을 이용해서 문자값을 비교하므로, 0x00이 테이블에 어디에 위치하느냐를 먼저 파악해야한다. 위 테이블에서는 테이블의 시작 + 240 바이트에 위치하는 곳부터 10 바이트의 길이만큼 0x00으로 채워져있는 것을 확인할 수 있다. 즉, 240부터 250까지의 값을 유효한 값으로 보겠다는 의미가 된다. 240을 Hex 값으로 변환하면 0xF0이 된다. 그리고 0xF0은 EBCDIC 코드 기준으로 숫자 0이 된다. 즉, 위의 테이블은 숫자 0부터 9까지를 유효한 값으로 판단하는 테이블임을 파악할 수 있다.

##### 문자들을 ASCII 기반의 Hex값으로 변환한다

어떤 문자를 유효한 값으로 검사하는지 파악했다면 해당 문자를 ASCII 기반의 Hex값으로 구하는 것은 어렵지 않다. 위의 예제의 숫자 0 ~ 9를 ASCII 기반의 Hex 값으로 변환하면 0x30 부터 0x39 까지임을 쉽게 알 수 있다.

##### 테이블을 ASCII 기반으로 새로 작성한다

이제 테이블을 새로 작성해보자. Hex값 0x30은 십진수로 48이다. 따라서 숫자 0부터 9까지를 검사하기 위한 ASCII 기반의 TRT 테이블은 아래와 같이 변경할 수 있다.

<pre>
TAB1    CL48' '
        XL10'00'
        CL198' '
</pre>

좀 더 직관적인 방법으로는 ORG 명령어를 사용하는 방법이 있다. 위 테이블을 ORG 명령어를 사용하면 아래와 같이 변경할 수 있다.

<pre>
TAB1    CL256' '
        ORG     TAB1+C'0'
        XL10'00'
        ORG
</pre>

좀 더 자세한 분석과 설명은 OF실 [Redmine#16064](http://tpredmine.tmax.co.kr/redmine/issues/16064) 를 참고바란다.

### DFHEIENT / DFHEIRET 매크로 수동 삽입

CICS 커맨드를 사용하는 어셈블러 자산의 경우 대개 DFHEIENT 매크로로 소스 코드가 시작하는 경우가 많다. 하지만 메인프레임에서는 CSECT나 START로 시작하는 CICS 사용 자산에 대해 자동적으로 CSECT 및 START 명령어 뒤에 DFHEIENT 매크로를 삽입해주는데, OFASM의 경우 일부 케이스에 한해서만 해당 매크로를 삽입해준다. 
다시 말해, 일부 케이스에 대해서는 DFHEIENT 매크로를 수동으로 넣어줘야한다.
DFHEIRET 매크로도 마찬가지인데, END 명령어가 나오기 전에 DFHEIRET 매크로를 삽입 해주어야 하는 일부 케이스가 있다. 

//TODO: DFHEIENT 및 DFHEIRET을 사용하지 않았을 때 발생하는 에러 케이스들 정리

